a comparison of spring mvc and JAX_RS
  
Introduction

over the past few years REST has become an important concept influencing the design of web frameworks, web protocols and applications.
if you haven't been exposed to it, see this brief introduction among many others you can find.
  
The ever growing importance of REST is not surprising considering the need for companies to expose web apis that should be as simple and as deeply rooted in the architecture of the web as can be. Rich browser clients communicating via Ajax can also see much of the same. and there is no reason why any web applicaiton can't benefit from the architectural principles that have helped to scale the world wide web.
  


JAX-RS is the java API for RESTful web services. JAX-RS was created with the participation of Roy Fielding who defined RESt in his thesis.
it provides those seeking to build RESTful web services an alternative to JAX-WS. there are currectly 4 JAX-RS implementations available,
all of which provide support for using Spring.

Jersey is the reference implemenation and the one used in this article.

Spring 3 adds comprehensive REST support for both web applicaitons and web services.

This article however will focus on features relating to the development of web services.
I believe this approach will make it easier to discuss spring mvc in the context of JAX-RS.

a second note to make is that the REST features we'll be discussing are a part of the Spring Framework and are continuation of the existing the Spring MVC programming model.
Hence there is no "spring REST framework" as ou might be tempted to say. It's just spring and spring MVC. what this practically means is that if you have an existing Spring application you can expect to be able to use Spring MVC both creating an HTML web layer and a RESTful web services layer.


About the code snippets
The code snippets shown throughout the article assume a simple domain model with two JPA-annotated entities named Account and Portfolio where an Account has many Portfolios.
The persistence layer is configured with spring and consists of a JPA repository implementation for retireving an persisting entity instances. Jersey and Spring MVC will be used to build a web services layer for servicing client requests by calling the underlying spring-managed application.

Bootstrap and wire the web layer
We will assume the use of Spring for dependency injection in both the spring mvc and the JAX-RS scenarios. The spring MVC DispatcherServlet and the Jersey SpringServlet will delegate requests to spring-managed REST-layer components(controllers or resources) that will in turn be wired with either business or persistence components as follows:

both jersey and spring mvc will rely on spring's contextLoaderListener to load business and persistence components such as the JpaAccountRepository:
<context-param>
  <param-name>contextConfigLocation</param-name>
  <param-value>
    classpath:META-INF/spring/module-config.xml
  </param-value>



An annotation, in the java computer programming language, is a form of syntactic metadata that can be added to java source code.
Classes, methods, variables, parameters and packages may be annotated.

Unlike Javadoc tags, java annotations can be reflective in that they can be embedded in class files generated by the compiler and may be retained by the Java VM to be made retrievable at run time. it is possible to create meta-annotations out of the existing ones in java.






declare root JAX-RS resources classes with some Spring and some JAX-RS annotations:

@Path("/accounts/")
@Component
@Scope("prototype")
public class AccountResource {
  
  @Context
  UriInfo uriInfo;

  @Autowired
  private AccountRepository accountRepository;
}

the following is a decription of the annotations:
@Component declares AccountResource as a spring bean
@Scope makes it a prototype Spring bean that's instantiated every time it is used (i.e. on each request).
@Autowired requests a reference on an AccountRepository, which spring will provide.
@Path is a JAX-RS annotation that declares AccountResource as a "root" JAX-RS resource.
@Context is also a JAX-RS annotation requesting the injection of the request-specific UriInfo object.
JAX-RS has the notion of "root" resources(marked with @Path) and sub-resources. in the example above AccountResoruce is a root resource
that handles paths starting with "/accounts/". Methods within AccountResource like getAccount() need only declare paths relative to the type-level path:

@Path("/accounts/")
@Component
@Scope("prototype")
public class AccountResource {

  @GET
  @Path("{username}")
  public Account getAccount(@PathParam("username") String username) {
  
  }
}

the path to "/accounts/{username}" where username is a path parameter and can take the value of any user name for a given account,
will be handed to the getAccount() method.

Root resources are instantiated by the JAX-RS runtime (Spring in this case). sub-resources on the other hand are instantiated b the application.
for example to handle requests for "/accounts/{username}/portfolios/{portfolioName}", the AccountResources, as identified by the leading portino of the path ("/accounts"),
will create an instance of a sub-resource to which the request will be delegated:

@Path("/accounts/")
@Component
@Scope("prototype")
public class AccountResource {

  @Path("{username}/portfolios/")
  public PortfolioResource getPortfolioResource(@PathParam("username") String username) {
    return new PortfolioResource(accountRepository, username, uriInfo);
  }
}


PortfolioResource itself is declared without annotations and will have all its dependencies passed down by the parent resource:

public class PortfolioResource {
  private AccountRepository accountRepository;
  private String username;
  private UriInfo uriInfo;

  public PortfolioResource(AccountRepository accountRepository, String username, UriInfo uriInfo) {
    this.accountRepository = accountRepository;
    this.username = username;
    this.uriInfo = uriInfo;
  }
}

keep in mind resource classes are web service layer components and should remain focused on web service related processing such as translating input, preparing the response, setting the response code, etc. it's also worth pointing out the practicalities of separating web services logic from business logic often necessitate wrapping business logic into a single method that serves as a transaction boundary.





RESTful Web Service -- JAX-RS Annotations
  
  @GET
  @Produces
  @Path
  @PathParam
  @QueryParam
  @POST
  @Consumes
  @FormParam
  @PUT
  @DELETE
    
  we are using Jersey for RESTful web services and JAX-RS annotations.

  REST follows one-to-one mapping between create, read, update, and delete (CRUD) operations and HTTP methods.
  to create a resource on the server, use POST.
  to retrieve a resource, use GET,
  to change the state of a resource or to update it, use PUT,
  to remove or delete a resource, use DELETE.

  @GET
  Annotate your Get request methods with @GET

  @Produces
  specifies the type of output this method (of web service) will produce

    examples:
      @GET
      @Produces("application/xml")
      public Contact getXML() {
      }
  
      @GET
      @Produces("application/json")
      public Contact getJSON() {
      }
  
  @Path
  @Path annotation specify the URL path on which this method will be invoked.
    example:
      @GET
      @Produces("application/xml")
      @Path("xml/{firstName}")
      public Contact getXML() {
      }

  @PathParam
  we could bind REST-style URL parameters to method arguments using @PathParam annotations as shown below.
    example:
      @GET
      @Produces("application/application/xml")
      @Path("xml/{firstName}")
      public Contact getXML(@PathParam("firstName") String firstName) {
        Contact contact = contactService.findByFirstName(firstName);
        return contact;
      }

      @GET
      @Produces("application/json")
      @Path("json/{firstName}")
      public Contact getJSON(@PathParam("firstName")  String firstName) {
        Contact contact = contactService.findByFirstName(firstName);
        return contact;
      }

  @QueryParam
  request parameters in query string can be accessed using @QueryParam annotation as shown below.
    example:
      @GET
      @Produces("application/json")
      @Path("json/companyList")
      public CompanyList getJSON(@QueryParam("start") int start, @QueryParam("limit") int limit) {
        CompanyList list = new CompanyList(companyService.listCompanies(start, limit));
      }

  @POST
  Annotate POST request methods with @POST.
    example:
      @POST
      @Consumes("application/json")
      @Produces("application/json")
      public RestResponse<Contact> create(Contact contact) {
      
      }

  @Consumes
  the @Consumes annotation is used to specify the MIME media type a REST resource can consume.
    Example:
      @PUT
      @Consumes("application/json")
      @Produces("application/json")
      @Path("{contactId}")
      public RestResponse<Contact> update(Contact contact) {
      }

  @FormParam
  the REST resources will usually consume XML/JSON for the complete Entity Bean. Sometimes, you may want to read parameters sent in POST requests directly and you can do that using @FormParam annotation. Get Request query parameters can be accessed using @QueryParam annotation.
    Example:
      @POST
      public String save(@FormParam("firstName") String firstName, @FormParam("lastName") String lastName) {
      
      }

  @PUT
  Annotate PUT request methods with @PUT.
    Example:
      @PUT
      @Consumes("application/json")
      @Produces("application/json")
      @Path("{contactId}")
      public RestResponse<Contact> update(Contact contact) {
      }

  @DELETE
  annotate DELETE request methods with @DELETE
    Example:
      @DELETE
      @Produces("application/json")
      @Path("{contactId}")
      public RestResponse<Contact> delete(@PathParam("contactId") int contactId) {
      }





Hibernate --- JPA annotations

@Entity
  annotate all your entity beans with @Entity.
  @Entity
  public class Company implements Serializable {
  }

@Table
  Specify the database table this Entity maps to using the name attribute of @Table annotation. In the example below, the data will be stored in 'company' table in the database.
  @Entity
  @Table(name = "company")
  public class Company implements Serializable {
  }

@Column
  Specify the column mapping using @Column annotation.
  @Entity
  @Table(name="company")
  public class Company implements Serializable {
    @Column(name="name")
    private String name;
  }


@Id
  annotate the id column using @Id.
  @Entity
  @Table(name="company")
  public class Company implements Serializable  {
    @Id
    @Column(name="id")
    private int id;
  }


@GeneratedValue
  let the database generate (auto-increment) the id column.
  @Entity
  @Table(name="company")
  public class Company implements Serializable {
    @Id
    @Column(name="id")
    @GeneratedValue
    private int id;
  }











